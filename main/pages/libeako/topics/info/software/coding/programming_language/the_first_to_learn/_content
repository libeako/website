\ id njbmaqiznfzdylnr
* this is last maintained in 2020-03
* i as a programmer was asked multiple times : which programming language an aspiring programmer should learn first; now i think i have the answer settled in my mind
* it is elm
* link to elm
	\ links-to external https://elm-lang.org
* because
	* it is functional
		* i wrote about (functional programming) too
			\ links-to internal rqeeitsvmgrogdjp
	* it is simple
		* it is high level; the programmer does not need to deal with [and hence learn] low level things like memory management
		* its type system is weak : lacks even type function polymorphism; this prevents elm programmers to use abstractions that are difficult for a beginner programmer [like monad]; hence all the material one can find on the internet related to elm is without these advanced topics - this makes elm a safe space to learn programming, where one can comfortably learn only the basics first
		* most importantly it does not contain any bad feature that are present in many highly popular programming languages; such features not only make the learning significantly more difficult but also mislead the beginner to incorrect knowledge and very bad programming style; the most notable example of such bad language feature is object oriented programming; elm is fortunately not object oriented; this makes it much easier to learn and leads to cleaner programmer mind; other bad stuff that elm avoids include: imperative instructions, control flow structures, null values and exceptions
			* why is object oriented programming bad
				\ links-to internal kgmqzsduacpzvbxy
			* why are null value is bad
				\ links-to internal fbctgaodsnjovfll
		* due to its functional nature and the restriction of the features to only the very basic ones : the whole language is super simple, straightforward, intuitive, a breeze to learn
	* ease of simple web GUI construction
		* this is not necessary to learn programming, but beginners often desire it
* too simple for professional use
	* one of its advantages is also its big disadvantage: it is too simple; the most hurting problem is the lack of  type function polymorphism; hence if one wants to move beyond the baby steps then must switch to a more advanced language; for that 'haskell' is a perfect choice
		* link to (type function polymorphism)
			\ links-to internal eyfagqcuwwajcnmt
		* link to 'haskell'
			\ links-to external https://www.haskell.org/
