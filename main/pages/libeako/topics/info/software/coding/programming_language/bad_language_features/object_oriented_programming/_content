\ id kgmqzsduacpzvbxy
* what is "object oriented" programming?
	* first of all: a paradigm can not contain something that is not distinctive of other paradigms
		* if a language feature is present in languages generally than that feature is not distinctive and hence can not be part of a programming paradigm, like OO
	* to define "object oriented" is difficult task; the meaning is widely debated; in such situation it is good to go to 
	* objective criteria to interpret the term
		* the meaning of the term
			* an "object" is a value with an identity [usually identified by its storage location in memory]; the reason to distinguish between different objects with the same value is and only is the possibility of mutation; the functional paradigm does not have objects; hence "object" is equivalent to imperativeness
		* the original meaning of the author of the term
			* the term "object oriented" was coined by Alan Kay; the most informative text about his thinking about it that i found is "OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things."
			* my interpretation of Alan Kay's definition
				* imperativeness
					* he talks about state, which suggests [though does not surely imply] that he meant imperativeness
					* "local retention and protection and hiding of state-process" - i interpret this as just hiding of the representation of the data type of the state; but hiding anyhing is a simple natural feautre, practically all languages provide this feature; hence it is not a distinctive
				* "late-binding" means that the methods are dispatched dynamically
		* the practice of using the term
			* let us identify OO languages and non-OO languages and see what is the differene between them
			* some of the languages most known as OO are Java, C#
			* the language most known as not-OO is Haskell
			* the difference between them mostly is imperativeness and the method dispatch being dynamic; Haskell is famous about being the opposite of these features
	* conclusion of the objective criteria: OO is imperativeness and the method dispatch being dynamic
		* these 2 things are independent of each other
			* this suggests either that my definition of OO is wrong or that OO is something wrong; i think my interpretation is good and OO is wrong
	* other opinions
		* one modern interpretation of OO is that imperativeness does not have to be a part of it; this view is strongly shown by the Scala language, for example
			* this is often referred to with the name "functional OOP"; but the name mainly contains "object", which means imperativeness, hence this name is inconsistent
		* one opinion is that "object" means not imperativeness but "message passing", but that must be wrong, because message passing of OO is just method invokation, which is part of all languages, not a distinctive feature
		* what else could OOP be? 
			* run-time type testing? - even the OO culture considers it a dirty practise, to be avoided
			* method implementation inheritance? - Haskell has it too
			* dynamic binding? - haskell also has it, though with more code verbosity
* main conclusion
	* till here i came to the conclusion that OOP is mainly state mutation and unnecessary push of dynamic binding; the earlier ruins our software coding efficiency, the later makes type interfacing hardly usable; giving nothing significant in return that we would expect from a programming paradigm
* OO is wrong
	* to see why we need to decompose OO into its 2 components
	* imperative programming
		* may have some legitimacy in simple low level programming, but otherwise it is idiotic
		* link to 'functional programming'
			\ links-to internal rqeeitsvmgrogdjp
	* dynamic method dispatch
		\ links-to internal ejqltwjmfjcvjpnf
	* in most languages both imperativeness and the method dispatch being dynamic are bad ideas, but these 2 features together form an unfortunate combination as this combination is wrong in all languages; imperativeness may be good for simple languages for high manual control over run-time efficiency; but for that dynamic dispatch is wrong, as it is slow
* why did OO spread?
	* if OOP would be so clearly bad then why did it spread so widely? because the languages that pushed it became popular; but those became popular not because of OOP but each for some unrelated reason; for example java, c# were backed by big companies, java additionally promised "write once, run everywhere", c++ did not have a competitor
* OO mania
	* it is not only the languages, but culture too; so named "OO design patterns", "OO design", "OO architecture" flud the industrial software development world; i think that was a mistake
	* i am not familiar with the "OO design patterns", but i want to show you that they are not valuable; hence i searched the web for OO design patterns and found
	* a website listing many of them
		\ links-to external https://www.oodesign.com/proxy-pattern.html
	* i worked through all of them, here are my quick impressions about them :
	* the list
		* "decorator"
			* = let us decrease the inheritance hierarchy, by replacing some inheritance with aggregation
			* but : realizing that a more basic language construct [product type] is more adequate than a more involved one [inheritance] is not a "design pattern"; because to apply the more involved language construct is not a task to be solved
		* "flyweight"
			* = data reference :-) ["pointer" if you like]; yes : some people think it needs a different name and articles
		* "factory"
			* = stream
		* "composite"
			* = tree
		* "strategy"
			* = second order function, which is just function with function input : (x -> y) -> r
		* "command"
			* = special case of "strategy", where the input function is an action
		* "builder"
			* = special case of strategy, where the input function produces something instead of performing an action
		* "singleton"
			* = lazy initialization + mutable global state
		* "state"
			* = access control + mutable state
		* "null object"
			* monoid
				\ links-to internal cabjryjnnstdjmvb
		* "template method"
			* = "strategy"
		* "prototype"
			* = changing things slightly = optics
		* "interpretation"
			* = denotational semantics
			* in this role sum types work better because in a language the constructs [the production rules] are usually not extensible
		* "iterator"
			* = imperative traversable
				* see (Jeremy Gibbons and Bruno Oliveira : "The essence of the Iterator pattern")
					\ links-to external http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator
			* this is an example of the rare situation that the OO style is easier to understand, more intuitive
		* "visitor"
			* the action performed by the "iterator"; "iterator" and "visitor" are 2 components of a single design pattern
		* "memento"
			* = cloning, which is not needed with the absence of mutation
		* "observer"
			* is an inherently OO solution; because it extends updating [an imperative thing] and designates a central object through which to drive the update; a perfect example for domain is user interface; i am not knowledgable in the domain of UI but i know that functional UI exist and its practitioners like it; at first thought it seems closest to the concept of traversal in functional programming; the OO version is more simple and intuitive
		* "bridge"
			* i did not understand this one in the 10 minutes i was willing to spend on it
		* not OO specific
			* "resource pool"
			* no real relation to  OO
				* "proxy"
					* = layering
				* "mediator"
					* seems to be equivalent to a 2-input function
				* "adapter"
				* "chain of responsibility"
	* i hope i understood most of them correctly
	* note that for most of them at least one of the following statements is true
		* involves mutable state; though in a few cases the functional equivalent is less intuitive : altogether the functional [controlled] state handling is almost always a better solution because of the enormous advantages of functional programming
		* just renames some very simple notion
		* unnecessarily overcomplicates some very simple notion with OO clothing
		* no real relation to OO [its categorization into "OO design patter" is incorrect]
	* how did this OO overusage evolve ?
		* certain very popular OOP languges [java, c#] initially lacked essential language features [first class function, parametric type polymorphism, sum type] and by this they forced their users to use subtyping for all polymorphic problems; hence OOP became overused and people got used to overusing it
* without OO
	* can we do without OO? fortunately we already have enough practical experience to answer this question with confidence; haskell people are fine without OO; haskell does not provide OO and its users do not miss it at all
