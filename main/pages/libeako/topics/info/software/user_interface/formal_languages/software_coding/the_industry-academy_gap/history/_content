* the dark age
	* when the 2 worlds [industry, academy] were almost totally separate :
	* academy
		* Fortran was the first language with a serious compiler; only one year after its release [which happened in 1957] the Lisp programming language appeared, which later became suitable for functional programming
		* in the 1970s the programming language ML appeared, which was designed to be functional and have a good type system
		* the academy world strengthened its belief and presence in functional programming and in the 1980s it turned towards purely functional programming, which excludes side-effects from the programming language semantics
		* this change process ended in the creation of the Haskell programming language
		* yet an other topic in which the academy achieved very noteworthy results is code abstractions
			* the key in the success was the utilization of mathematics, mostly category theory
			* most of this development happened in Haskell
		* beside functional programming: the other big topic of the academy is static type systems, and the academy achieved much good in it; the current state of the art is that type systems should be built on a core named "calculus of constructions", which is very powerful and simple and natural; which is very powerful and simple and natural; programming languages with such type systems unify coding with logic, and by this they bring us the ability to use a simple general purpose programming language not only for software implementation, but also for mathematical modelling, specifying, verifying; now, in 2019 unfortunately haskell does not have this; yet; some programming languages exist that have it, but they are not industry-strong yet
	* industry
		* some major industry languages were Fortran, C, C++, Java, C#, Python
		* they all were imperative, and the later ones are all "object-oriented"
			* object orientation is bad
				# links-to internal kgmqzsduacpzvbxy
		* C and especially Fortran are very early languages and their design were also loaded with the requirement to be very fast and easy to implement; with this in mind : i think they are good enough for their time and purpose
		* but C++, Java, C#, Python are from the 1990s, when the academy languages have already proved how to do much better; the designs of these industry languages are totally amature for their time; their designers seemingly did not even look in the academy world of programming language theory, which is more than 20 years ahead of them; these industry languages are spread very wide; but not because the [non-existent] merits in their design, but because some other, practical reasons
* the gap shrinking
	* C# became the latest popular programming language that totally neglected academy; hence i consider it the top of the industrial idiotism in programming language design
	* C# started around 2000
	* soon after that a turning point happened and the enlightenment of the industry began, it did turn towards academy
		* the turning point is marked by 2 programming languages : F#, Scala; their concept is the same : good programming platforms exist [Java, .Net], but their languages are bad, lets create better languages for these platforms; and better was more like academic : these new languages were both more functional and had stronger static type systems then their idiotic counterparts
	* since that turning point the industrial languages are slowly continuing what Scala and F# started
	* the change in the industry's attitude towards academy is not only still happening, but already some little signs are visible of that the gap may be getting closed
		* as witnesses of this statement 2 langauges are to note : Idris, F*
			* they are designed for general purpose
			* they are purely functional languages with modern, very powerful type systems [calculus of constructions]; this type system is simple, intuitive, mathematically well founded and very powerful; programming languages with such type systems unify coding with logic, and by this they bring us the ability to use a simple general purpose programming language not only for software implementation, but also for mathematical modelling, specifying, verifying
			* Fis a Microsoft product, and it looks like Microsoft does not do any other serious language design currently, hence i hope Fto become Microsoft's next main programming language, their apology for C#
			* these languages are in about beta stage [2019.08]
