\ id kdtdlfyrudrcnrrl
* logic emerges from type theory; logical concepts can be represented by the most basic type theoretical concepts; logical propositions can be represented by types; the importance of this simple and natural idea is fundamental and huge
* the name of this idea
	* is "propositions as types"
		* because it represents propositions as types
	* sometimes the name "Curry Howard correspondence" is used
	* it is not overstatement that this is a most fundamental science development in the 20th century
	* this is one of the greatest piece of knowledge i have ever learned in programming
* this idea can be used both in mathematics and in programming
	* the similarities between math and programming is not a coincidence, the outer-most layer of programming is math, as both of them are just about construction of mathematial objects
		* programs are mathematical objects
			* even if their use case is not specially mathematical
* we need logic
	* on what we construct: we want to make sure that certain properties are true; for that we need to be able to express these properties formally as propositions, prove them and verify the proof automatically
* the logic must be about the program itself, not about its data
	* of course the constructive world can and always could express anything generally, including logical concepts; for example we can write a program that lets the user edit propositions, proofs and verify the proofs; but this would work only on the data layer of the program; those propositions would be about data layer objects; but we want to prove properties of our program itself
* this idea achieves this goal by letting logic emerge from the typing of the constructive language
	* hence logic does not need a separate language (other than the language of construction)
* derivation of the core idea
	\ links-to internal ekondytrrodzxtui
* the core idea
	* the proposition represented by a type is true if and only if the type is inhabited
* how can we prove a proposition? the question translates to types as follows: how can we prove that a type is inhabited? the answer is trivial: we show an instance of the type; by 'show' i mean we declare it to have that type and give a definition to it; the static type-checking is the verification of the proof
* examples of representing simple statements
	* equality
		\ links-to internal cteoxhjanjufrioe
* the proposition as type idea can be proved to be correct by a simple structural induction - induction on the structure of the statements; statements can be either primitive or composite
	* among [the types representing] the primitive statements no relation exists, hence no consistency problems may be
	* hence all is needed is to prove the consistency of the representation of composite statements, which can be done individually per type of logical construct
* notation for the work that follows
	* multiple names are used to refer to empty types: "()" [- the empty tuple type], "Empty", "False", "Absurd"
	* representation correspondence
		* rep : Proposition -> Type
			* outputs the type representing the input proposition
		* derep : Type -> Proposition
			* inverse of rep
* representing logical constructs
	\ links-to internal huktyxsxcfntvnbj
* representing logical axioms
	\ links-to internal tucpuipfoxmuftxd
* appreciation
	* it is remarkable that now we can use a single simple functional programming language to model the world [domain of the client], propose statements about the world, prove those statements, specify the task of a program, implement the program, verify that the program fulfills the specification
* additional sources
	\ links-to internal ekondytrrodzxtui
