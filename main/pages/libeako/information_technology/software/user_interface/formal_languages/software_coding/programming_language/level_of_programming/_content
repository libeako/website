* i mean "level" in the sense of this order : hardware -> assembly programming language -> c -> java -> haskell
* i know about 2 kinds of levels
	* conceptual - how we humans think about the program
	* technical - what is done automatically by the compiler and the run-time environment instead of the human coder
* conceptual level
	* imperative
		* the program is a list of instructions; specifies what the machine to do
	* functional
		* the program is a set of equations 
		* see more
			# links-to internal zxsbxwlppaypmpnn
	* logic
		* the program is a set of logical statements about the input and output of the program
		* the computation of a program specified thus takes often asymptotically more runtime than an equivalent functional program
* technical level
	* automation
		* memory management
			* in this section i clear some terminology that i feel are often used incorrectly
			* example of a language that does not have any automatism in memory management is c
			* garbage disposal
				* "disposal" is a better word than "collection"
					* collection is just a part of disposal, but we also want to reclaim the memory of the identified garbage
					* some garbage disposal systems are not stop-the-world, do not have a collecting phase
						* for example : reference counting
				* c++ programming has partially automatic garbage disposal; by RAII, smart pointers; circular references are not discoverable with those though
				* java, haskell has fully automatic garbage disposal, including of circles
			* layout management
				* whether an object contains an other [as in memory] or refers to it with a pointer
		* evaluation order
			# links-to internal gvlvjsxsrqfqfght
		* maintaining thread pools, the programmer only needs to specify "task"s
	* effect on runtime efficiency
		# links-to internal yjnweovfnkfncnhp
