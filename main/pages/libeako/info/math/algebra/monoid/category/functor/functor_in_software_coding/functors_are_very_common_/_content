* for product and sum type construction one can define functors in the natural way
* functions by their output type also form functors; one can thing about a function as a container with exactly one element but whose evaluation is postponed because it has a dependency, which is the input of the function
* very many important data types are constructed by the above ones, hence form functors
	* every type function that we think of as a collection is a functor
		* List
		* Array
		* Maybe
		* Either l
			* type function Either has 2 parameters, one for each case ["left", "right"]
			* i consider (Either l) to be a partial application of the multi-input type function Either; its type is still a type function, which has 1 input
		* (x -> )
* hence functor is a good candidate for generic implementation via the data structure; because functor is a very important interface : the haskell compiler provides built-in automatism that can implement it for most types [without run-time overhead]
	* link to "abstraction over data-structure"
		# links-to internal xkvczulejoaflnjf
